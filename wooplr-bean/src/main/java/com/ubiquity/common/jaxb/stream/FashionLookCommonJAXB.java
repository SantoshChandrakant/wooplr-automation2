//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vhudson-jaxb-ri-2.1-833 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2015.04.11 at 01:55:25 PM IST 
//

package com.ubiquity.common.jaxb.stream;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlType;

import com.ubiquity.common.jaxb.ecomm.Countable;

/**
 * <p>
 * Java class for FashionLookJAXB complex type.
 *
 * <p>
 * The following schema fragment specifies the expected content contained within
 * this class.
 *
 * <pre>
 * &lt;complexType name="FashionLookJAXB">
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element name="id" type="{http://www.w3.org/2001/XMLSchema}Long"/>
 *         &lt;element name="text" type="{http://www.w3.org/2001/XMLSchema}string"/>
 *         &lt;element name="imageId" type="{http://www.w3.org/2001/XMLSchema}string"/>
 *         &lt;element name="externalLink" type="{http://www.w3.org/2001/XMLSchema}string"/>
 *         &lt;element name="webLink" type="{http://www.w3.org/2001/XMLSchema}string"/>
 *         &lt;element name="tags" type="{http://www.w3.org/2001/XMLSchema}string" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="userDetails" type="{}StreamUserDetailJAXB"/>
 *         &lt;element name="comments" type="{}StreamRecommendationActionSmallJAXB" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="fashionItems" type="{}FashionItemJAXB" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element name="loveCount" type="{http://www.w3.org/2001/XMLSchema}Long"/>
 *         &lt;element name="commentCount" type="{http://www.w3.org/2001/XMLSchema}Long"/>
 *         &lt;element name="viewCount" type="{http://www.w3.org/2001/XMLSchema}Long"/>
 *         &lt;element name="hasBuyable" type="{http://www.w3.org/2001/XMLSchema}Boolean"/>
 *         &lt;element name="createDate" type="{http://www.w3.org/2001/XMLSchema}dateTime"/>
 *         &lt;element name="mobile" type="{http://www.w3.org/2001/XMLSchema}Boolean"/>
 *         &lt;element name="source" type="{http://www.w3.org/2001/XMLSchema}string"/>
 *         &lt;element name="latitude" type="{http://www.w3.org/2001/XMLSchema}Double"/>
 *         &lt;element name="longitude" type="{http://www.w3.org/2001/XMLSchema}Double"/>
 *       &lt;/sequence>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 *
 *
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "FashionLookCommonJAXB", propOrder = { "id", "lookText", "tags", "userId", "userDetails", "comments",
		"fashionItems", "fashionLooksProductJAXB", "lookLoves", "loveCount", "commentCount", "hasBuyable", "source",
		"isloggedInUserFollowLooks", "legacy", "image_pid", "isLinked", "isTagged", "isStaffPick", "curatorAddedTags",
		"webLink", "lookSource", "cursor", "viewCount", "curatorTitle" })
@XmlRootElement
public class FashionLookCommonJAXB implements Serializable, Countable {

	private final static Long serialVersionUID = 12343L;
	protected Long id;
	@XmlElement(required = true)
	protected String lookText;
	// @XmlElement(required = true)
	// protected String imageId;

	@XmlElement(nillable = true)
	protected List<String> tags;
	protected Long userId;
	@XmlElement(required = true)
	protected LookUserDetailJAXB userDetails;
	@XmlElement(nillable = true)
	protected List<StreamRecommendationActionSmallJAXB> comments;
	@XmlElement(nillable = true)
	protected List<FashionItemJAXB> fashionItems;
	@XmlElement(nillable = true)
	protected List<FashionItemEcommSmallProductJAXB> fashionLooksProductJAXB;
	@XmlElement(nillable = true)
	protected List<LookUserDetailJAXB> lookLoves;
	protected Long loveCount;
	protected Long commentCount;

	protected Boolean hasBuyable;
	@XmlElement(required = true)
	protected String source;
	@XmlElement(defaultValue = "false")
	protected Boolean isloggedInUserFollowLooks;
	@XmlElement(defaultValue = "false", type = Boolean.class)
	protected Boolean legacy = false;
	protected String image_pid;
	protected Boolean isLinked;
	protected Boolean isTagged;
	private Boolean isStaffPick;
	private List<String> curatorAddedTags;
	private String webLink;
	private String lookSource;
	private String cursor;
	protected Long viewCount;
	private Boolean verified;
	protected String curatorTitle;

	public String getWebLink() {
		return webLink;
	}

	public void setWebLink(String webLink) {
		this.webLink = webLink;
	}
	// private StreamImageDetailsJAXB imageDetails;

	public Boolean getLegacy() {
		return legacy;
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public void setLegacy(Boolean legacy) {
		this.legacy = legacy;
	}

	public List<FashionItemEcommSmallProductJAXB> getFashionLooksProductJAXB() {
		if (fashionLooksProductJAXB == null) {
			fashionLooksProductJAXB = new ArrayList<FashionItemEcommSmallProductJAXB>();
		}
		return this.fashionLooksProductJAXB;
	}

	public Boolean isSetFashionLooksProductJAXB() {
		return ((this.fashionLooksProductJAXB != null) && (!this.fashionLooksProductJAXB.isEmpty()));
	}

	public void unsetFashionLooksProductJAXB() {
		this.fashionLooksProductJAXB = null;
	}

	public Boolean getIsloggedInUserFollowLooks() {
		return isloggedInUserFollowLooks;
	}

	public void setIsloggedInUserFollowLooks(Boolean isloggedInUserFollowLooks) {
		// System.out.println("Why am I here1234");
		this.isloggedInUserFollowLooks = isloggedInUserFollowLooks;
	}

	public Boolean isSetIsloggedInUserSharedRecommendation() {
		return true;
	}

	/**
	 * Gets the value of the text property.
	 *
	 * @return possible object is {@link String }
	 *
	 */
	public String getText() {
		return lookText;
	}

	/**
	 * Sets the value of the text property.
	 *
	 * @param value
	 *            allowed object is {@link String }
	 *
	 */
	public void setText(String value) {
		this.lookText = value;
	}

	public Boolean isSetText() {
		return (this.lookText != null);
	}

	/**
	 * Gets the value of the imageId property.
	 *
	 * @return possible object is {@link String }
	 *
	 */
	/*
	 * public String getImageId() { return imageId; }
	 */
	/**
	 * Sets the value of the imageId property.
	 *
	 * @param value
	 *            allowed object is {@link String }
	 *
	 */
	/*
	 * public void setImageId(String value) { this.imageId = value; }
	 * 
	 * public Boolean isSetImageId() { return (this.imageId!= null); }
	 */

	/**
	 * Gets the value of the tags property.
	 *
	 * <p>
	 * This accessor method returns a reference to the live list, not a
	 * snapshot. Therefore any modification you make to the returned list will
	 * be present inside the JAXB object. This is why there is not a
	 * <CODE>set</CODE> method for the tags property.
	 *
	 * <p>
	 * For example, to add a new item, do as follows:
	 * 
	 * <pre>
	 * getTags().add(newItem);
	 * </pre>
	 *
	 *
	 * <p>
	 * Objects of the following type(s) are allowed in the list {@link String }
	 *
	 *
	 */
	public List<String> getTags() {
		if (tags == null) {
			tags = new ArrayList<String>();
		}
		return this.tags;
	}

	public Boolean isSetTags() {
		return ((this.tags != null) && (!this.tags.isEmpty()));
	}

	public void unsetTags() {
		this.tags = null;
	}

	public void setTags(List<String> tags) {
		this.tags = tags;
	}

	public LookUserDetailJAXB getUserDetails() {
		return userDetails;
	}

	public void setUserDetails(LookUserDetailJAXB userDetails) {
		this.userDetails = userDetails;
	}

	public Boolean isSetUserDetails() {
		return (this.userDetails != null);
	}

	/**
	 * Gets the value of the comments property.
	 *
	 * <p>
	 * This accessor method returns a reference to the live list, not a
	 * snapshot. Therefore any modification you make to the returned list will
	 * be present inside the JAXB object. This is why there is not a
	 * <CODE>set</CODE> method for the comments property.
	 *
	 * <p>
	 * For example, to add a new item, do as follows:
	 * 
	 * <pre>
	 * getComments().add(newItem);
	 * </pre>
	 *
	 *
	 * <p>
	 * Objects of the following type(s) are allowed in the list
	 * {@link com.ubiquity.common.jaxb.stream.StreamRecommendationActionSmallJAXB }
	 *
	 *
	 */
	public List<StreamRecommendationActionSmallJAXB> getComments() {
		if (comments == null) {
			comments = new ArrayList<StreamRecommendationActionSmallJAXB>();
		}
		return this.comments;
	}

	public void setComments(List<StreamRecommendationActionSmallJAXB> comments) {
		this.comments = comments;
	}

	public void setFashionLooksProductJAXB(List<FashionItemEcommSmallProductJAXB> fashionLooksProductJAXB) {
		this.fashionLooksProductJAXB = fashionLooksProductJAXB;
	}

	public Boolean isSetComments() {
		return ((this.comments != null) && (!this.comments.isEmpty()));
	}

	public void unsetComments() {
		this.comments = null;
	}

	/**
	 * Gets the value of the fashionItems property.
	 *
	 * <p>
	 * This accessor method returns a reference to the live list, not a
	 * snapshot. Therefore any modification you make to the returned list will
	 * be present inside the JAXB object. This is why there is not a
	 * <CODE>set</CODE> method for the fashionItems property.
	 *
	 * <p>
	 * For example, to add a new item, do as follows:
	 * 
	 * <pre>
	 * getFashionItems().add(newItem);
	 * </pre>
	 *
	 *
	 * <p>
	 * Objects of the following type(s) are allowed in the list
	 * {@link com.ubiquity.common.jaxb.stream.FashionItemJAXB }
	 *
	 *
	 */
	public List<FashionItemJAXB> getFashionItems() {
		if (fashionItems == null) {
			fashionItems = new ArrayList<FashionItemJAXB>();
		}
		return this.fashionItems;
	}

	public Boolean isSetFashionItems() {
		return ((this.fashionItems != null) && (!this.fashionItems.isEmpty()));
	}

	public void unsetFashionItems() {
		this.fashionItems = null;
	}

	/**
	 * Gets the value of the loveCount property.
	 *
	 */
	public Long getLoveCount() {
		return loveCount;
	}

	/**
	 * Sets the value of the loveCount property.
	 *
	 */
	public void setLoveCount(Long value) {
		this.loveCount = value;
	}

	public Boolean isSetLoveCount() {
		return true;
	}

	/**
	 * Gets the value of the commentCount property.
	 *
	 */
	public Long getCommentCount() {
		return commentCount;
	}

	/**
	 * Sets the value of the commentCount property.
	 *
	 */
	public void setCommentCount(Long value) {
		this.commentCount = value;
	}

	public Boolean isSetCommentCount() {
		return true;
	}

	public Boolean isSetViewCount() {
		return true;
	}

	/**
	 * Gets the value of the hasBuyable property.
	 *
	 */
	public Boolean isHasBuyable() {
		return hasBuyable;
	}

	/**
	 * Sets the value of the hasBuyable property.
	 *
	 */
	public void setHasBuyable(Boolean value) {
		this.hasBuyable = value;
	}

	public Boolean isSetHasBuyable() {
		return true;
	}

	public Boolean isSetMobile() {
		return true;
	}

	/**
	 * Gets the value of the source property.
	 *
	 * @return possible object is {@link String }
	 *
	 */
	public String getSource() {
		return source;
	}

	/**
	 * Sets the value of the source property.
	 *
	 * @param value
	 *            allowed object is {@link String }
	 *
	 */
	public void setSource(String value) {
		this.source = value;
	}

	public Boolean isSetSource() {
		return (this.source != null);
	}

	/**
	 * Gets the value of the latitude property.
	 *
	 */

	public Boolean isSetLongitude() {
		return true;
	}

	public String getImage_pid() {
		return image_pid;
	}

	public void setImage_pid(String image_pid) {
		this.image_pid = image_pid;
	}

	public Boolean getIsTagged() {
		return isTagged;
	}

	public void setIsTagged(Boolean isTagged) {
		this.isTagged = isTagged;
	}

	public Boolean getIsLinked() {
		return isLinked;
	}

	public void setIsLinked(Boolean isLinked) {
		this.isLinked = isLinked;
	}

	public Boolean getIsStaffPick() {
		return isStaffPick;
	}

	public void setIsStaffPick(Boolean staffPick) {
		this.isStaffPick = staffPick;
	}

	public List<String> getCuratorAddedTags() {
		return curatorAddedTags;
	}

	public void setCuratorAddedTags(List<String> curatorAddedTags) {
		this.curatorAddedTags = curatorAddedTags;
	}

	/*
	 * public StreamImageDetailsJAXB getImageDetails() { return imageDetails; }
	 * 
	 * public void setImageDetails(StreamImageDetailsJAXB imageDetails) {
	 * this.imageDetails = imageDetails; }
	 */

	public void setFashionItems(List<FashionItemJAXB> fashionItems) {
		this.fashionItems = fashionItems;
	}

	public String getCursor() {
		return cursor;
	}

	public void setCursor(String cursor) {
		this.cursor = cursor;
	}

	public List<LookUserDetailJAXB> getLookLoves() {
		return lookLoves;
	}

	public void setLookLoves(List<LookUserDetailJAXB> lookLoves) {
		this.lookLoves = lookLoves;
	}

	public String getLookSource() {
		return lookSource;
	}

	public void setLookSource(String lookSource) {
		this.lookSource = lookSource;
	}

	public Long getUserId() {
		return userId;
	}

	public void setUserId(Long userId) {
		this.userId = userId;
	}

	public Boolean getHasBuyable() {
		return hasBuyable;
	}

	public String getLookText() {
		return lookText;
	}

	public void setLookText(String lookText) {
		this.lookText = lookText;
	}

	public Long getViewCount() {
		return viewCount;
	}

	public void setViewCount(Long viewCount) {
		this.viewCount = viewCount;
	}

	public Boolean getVerified() {
		return verified;
	}

	public void setVerified(Boolean verified) {
		this.verified = verified;
	}

	public String getCuratorTitle() {
		return curatorTitle;
	}

	public void setCuratorTitle(String curatorTitle) {
		this.curatorTitle = curatorTitle;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o)
			return true;
		if (o == null || getClass() != o.getClass())
			return false;

		FashionLookCommonJAXB that = (FashionLookCommonJAXB) o;

		if (image_pid != null ? !image_pid.equals(that.image_pid) : that.image_pid != null)
			return false;
		if (lookText != null ? !lookText.equals(that.lookText) : that.lookText != null)
			return false;
		if (userId != null ? !userId.equals(that.userId) : that.userId != null)
			return false;

		return true;
	}

	@Override
	public int hashCode() {
		int result = lookText != null ? lookText.hashCode() : 0;
		result = 31 * result + (userId != null ? userId.hashCode() : 0);
		result = 31 * result + (image_pid != null ? image_pid.hashCode() : 0);
		return result;
	}
}
